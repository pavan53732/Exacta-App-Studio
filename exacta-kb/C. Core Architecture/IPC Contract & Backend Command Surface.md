# IPC Contract & Backend Command Surface

## Purpose
Define the versioned IPC contract between UI (frontend) and backend (Tauri/Rust).

This contract is the single source of truth for:
- Command names and schemas
- Event names and schemas
- Ordering and determinism guarantees
- Cancellation and timeouts
- Compatibility rules across UI/backend versions

---

## Scope
- Commands (requests)
- Responses (direct replies to commands)
- Events (push from backend to UI)
- Progress reporting
- Cancellation and timeouts
- Compatibility and versioning rules
- Transport framing rules for Tauri `invoke` and event emission

---

## Requirements (Non-Negotiable)
- MUST be versioned.
- MUST be deterministic.
- MUST be fail-closed: unknown command/event/version MUST be rejected safely and explicitly.
- MUST be correlation-id based: every request and all derived events must be traceable.
- MUST be auditable: the UI must be able to reconstruct what happened from emitted events and responses.
- MUST NOT leak secrets (API keys, credentials) in IPC payloads.

---

## Supported IPC Version
- `ipc_version = "1.0"`

---

## Transport Choice (V1)
- **Tauri `invoke`** for request/response
- **Tauri event channel** for streaming events

---

## Canonical Message Model

### Message Types
- **Request**: UI → backend
- **Response**: backend → UI (exactly one per request)
- **Event**: backend → UI (0..N per request, and also allowed outside requests, e.g., background index updates)

### Required IDs
- `request_id`: UUID generated by UI per request
- `correlation_id`: UUID generated by backend per operation (one intent/plan execution flow)
- `event_id`: UUID generated by backend per event
- `seq`: integer sequence number generated by backend, monotonically increasing per `correlation_id`

**Hard rule:** For a given `correlation_id`, events MUST be totally ordered by `seq` with no gaps and no duplicates.

### Time
- All timestamps MUST be ISO-8601.
- The backend SHOULD emit timestamps in UTC with `Z`.

---

## Base Envelopes

### Request Envelope (UI → backend)
```

{

"ipc_version": "1.0",

"type": "request",

"request_id": "uuid",

"sent_at": "ISO-8601",

"command": "OpenProject",

"payload": {}

}

```

### Response Envelope (backend → UI)
```

{

"ipc_version": "1.0",

"type": "response",

"request_id": "uuid",

"correlation_id": "uuid",

"sent_at": "ISO-8601",

"ok": true,

"result": {},

"error": null

}

```

### Event Envelope (backend → UI)
```

{

"ipc_version": "1.0",

"type": "event",

"event": "StateChanged",

"event_id": "uuid",

"sent_at": "ISO-8601",

"request_id": "uuid-or-null",

"correlation_id": "uuid",

"seq": 1,

"payload": {}

}

```

---

## Canonical Error Object
All failures MUST use this structure (even if UI shows a friendlier message):

```

{

"code": "IPC-001",

"category": "Protocol",

"severity": "fatal",

"message": "Protocol violation: missing request_id",

"technical_detail": "Request envelope did not include request_id",

"recovery_path": "Restart",

"retryable": false

}

```

### Error Categories (Canonical)
- `Protocol`
- `Validation`
- `State`
- `Resource`
- `FileSystem`
- `AI`
- `Build`
- `Security`
- `Configuration`

> The same taxonomy MUST align with your global error taxonomy. If your KB has a canonical registry, IPC should reference it.

---

## Protocol Error Codes (IPC-xxx)
These are reserved for IPC-layer failures (not "build failed" etc.):

| Code | Meaning | Typical Severity | Retryable |
| --- | --- | --- | --- |
| IPC-001 | Invalid envelope (missing required field) | fatal | false |
| IPC-002 | Unsupported `ipc_version` | fatal | false |
| IPC-003 | Unknown command | error | false |
| IPC-004 | Unknown event received by UI | warning | false |
| IPC-005 | Response does not match request (wrong request_id) | fatal | false |
| IPC-006 | Duplicate request_id detected | error | true (with new request_id) |
| IPC-007 | Event sequence violation (missing/duplicate seq) | fatal | false |
| IPC-008 | Timeout | error | true |
| IPC-009 | Payload schema validation failed | error | false |

---

## Determinism and Ordering Rules

### Deterministic Execution
Given identical:
- starting orchestrator state
- project state + fingerprints
- config fingerprint
- request sequence (including payloads)

…the backend MUST produce identical:
- state transitions
- gate decisions
- emitted events (names + ordering + critical payload fields)

### Event Ordering Rules (Hard)
For a given `correlation_id`:

1. `StateChanged` MUST be emitted before any events only valid in that new state.
2. If a plan is produced, `PlanProposed` MUST appear before any `DiffProposed` for that plan.
3. For each step:
   - `StepStarted` MUST occur before `StepCompleted`.
   - Exactly one `StepCompleted` MUST exist per started step.
4. `ErrorRaised` MAY occur at any time, but if it transitions state, a `StateChanged` MUST follow.

### Sequence Rule (Hard)
- `seq` MUST be present on all events.
- `seq` MUST start at `1` for each new correlation_id.
- `seq` MUST increment by exactly 1.
- If UI detects missing or duplicate `seq`, UI MUST treat as protocol failure (IPC-007).

---

## Tauri Transport Framing Rules (V1)

### Requests via `invoke`
- Each IPC request maps to one Tauri command invocation.
- UI sends the Request Envelope as the invoke payload (or an equivalent struct with identical fields).

### Responses from `invoke`
- Backend returns one Response Envelope.
- UI MUST validate:
  - `ipc_version` matches
  - `type == "response"`
  - `request_id` equals the original request_id
  - `ok` is boolean
  - exactly one of `result` or `error` is non-null

If any check fails: UI MUST surface IPC-005 or IPC-001 and stop execution.

### Events via Tauri event channel
- Backend emits events on a single channel name: `exacta:event`
- Payload MUST be the Event Envelope.

---

## State Constraints (High Level)
Backend MUST reject commands that are not valid for the current Orchestrator state with a structured State error (e.g., ST-001 style), not with silent ignoring.

Allowed states are defined in the Orchestration State Machine document; this IPC document only references them.

---

# Commands (V1) — Complete Table

**Common required field in every command payload:** `project_id` unless the command is `OpenProject`.

All command payloads MAY include:
- `timeout_ms` (integer) — if exceeded, backend returns `ok=false` with IPC-008.

## Command Table

### OpenProject
**Allowed states:** any (creates/sets project context)

Request payload:
```

{ "path": "string" }

```

Response result:
```

{

"project_id": "uuid",

"project_root": "string",

"detected_markers": ["string"]

}

```

Emitted events:
- `LogEntry` (INFO)
- `StateChanged` (to Idle if project open initializes orchestrator)

Common errors:
- CFG-xxx (invalid config)
- FS-xxx (path not found / permission denied)
- IPC-009 (schema)

---

### CloseProject
**Allowed states:** Idle, Failed, Completed (not allowed during Executing/Paused/Cancelling)

Request payload:
```

{ "project_id": "uuid" }

```

Response result:
```

{ "closed": true }

```

Emitted events:
- `StateChanged` (to Idle if needed)
- `LogEntry`

Common errors:
- ST-001 (invalid state)
- FS-xxx (unable to flush state)

---

### ExtractIntent
**Allowed states:** Idle

Request payload:
```

{ "project_id": "uuid", "user_input": "string" }

```

Response result:
```

{

"intent": {

"id": "uuid",

"type": "CreateProject|AddFeature|FixBug|BuildPackage|UnknownIntent",

"confidence": 0.0,

"raw_input": "string",

"target": { "files": ["string"], "symbols": ["string"], "description": "string" },

"constraints": [ { "type": "MUST|MUST_NOT|PREFER", "description": "string", "scope": "string" } ],

"timestamp": "ISO-8601"

}

}

```

Emitted events:
- `StateChanged` (Idle → ExtractingIntent → Idle OR Planning-ready)
- `LogEntry`
- `ErrorRaised` (if rejected)

Common errors:
- AI-xxx (provider unreachable)
- VAL-001 (invalid/unknown intent)
- IPC-008 (timeout)

---

### GeneratePlan
**Allowed states:** ExtractingIntent completed successfully OR Idle with valid intent_id

Request payload:
```

{ "project_id": "uuid", "intent_id": "uuid" }

```

Response result:
```

{ "plan_id": "uuid", "version": 1, "status": "pending" }

```

Emitted events:
- `StateChanged` (→ Planning, → AwaitingApproval)
- `PlanProposed`
- `Progress`
- `LogEntry`

Common errors:
- VAL-004 (plan validation failed)
- RES-001 (token budget exceeded)
- AI-xxx

---

### ValidatePlan
**Allowed states:** AwaitingApproval (or immediately after plan generation)

Request payload:
```

{ "project_id": "uuid", "plan_id": "uuid" }

```

Response result:
```

{ "valid": true, "violations": [] }

```

Violations (when valid=false):
```

{

"valid": false,

"violations": [

{ "code": "PV-1", "message": "Plan must have at least one step" }

]

}

```

Emitted events:
- `LogEntry`
- `ErrorRaised` (if invalid)

---

### ApprovePlan
**Allowed states:** AwaitingApproval

Request payload:
```

{ "project_id": "uuid", "plan_id": "uuid" }

```

Response result:
```

{ "plan_id": "uuid", "status": "approved" }

```

Emitted events:
- `StateChanged` (AwaitingApproval → Executing) only when ExecutePlan is called; approval alone does not start execution.
- `LogEntry`

Common errors:
- ST-001
- VAL-005 (plan expired)

---

### RejectPlan
**Allowed states:** AwaitingApproval

Request payload:
```

{ "project_id": "uuid", "plan_id": "uuid" }

```

Response result:
```

{ "plan_id": "uuid", "status": "rejected" }

```

Emitted events:
- `StateChanged` (AwaitingApproval → Idle)
- `LogEntry`

---

### ExecutePlan
**Allowed states:** AwaitingApproval with approved plan

Request payload:
```

{ "project_id": "uuid", "plan_id": "uuid" }

```

Response result:
```

{ "execution_id": "uuid" }

```

Emitted events (typical):
- `StateChanged` (→ Executing)
- `StepStarted` / `DiffProposed` / `StepCompleted` (per step)
- `Progress`
- `LogEntry`
- `ErrorRaised` on failure
- `StateChanged` to Completed/Failed/Cancelling

Common errors:
- VAL-005 (drift detected)
- FS-xxx (file write failure)
- BLD-xxx (build failure)
- ST-001 (invalid state)

---

### Pause
**Allowed states:** Executing (between steps only)

Request payload:
```

{ "project_id": "uuid", "execution_id": "uuid" }

```

Response result:
```

{ "execution_id": "uuid", "status": "paused" }

```

Emitted events:
- `StateChanged` (Executing → Paused)
- `LogEntry`

Edge rule:
- If a step is mid-atomic operation, backend MUST finish the atomic boundary first, then pause.

---

### Resume
**Allowed states:** Paused

Request payload:
```

{ "project_id": "uuid", "execution_id": "uuid" }

```

Response result:
```

{ "execution_id": "uuid", "status": "executing" }

```

Emitted events:
- `LogEntry`
- `StateChanged` (Paused → Executing) only after revalidation passes

Revalidation requirements:
- drift/fingerprint checks MUST pass before resuming

---

### Cancel
**Allowed states:** Executing, Paused, AwaitingApproval

Request payload:
```

{ "project_id": "uuid", "execution_id": "uuid" }

```

Response result:
```

{ "execution_id": "uuid", "status": "cancelling" }

```

Emitted events:
- `StateChanged` (→ Cancelling)
- `LogEntry`
- `Progress` (rollback progress)
- `StateChanged` (→ Idle or Failed if rollback fails)

Hard rule:
- Cancel MUST NOT interrupt atomic file writes mid-write.

---

### ApplyDiffSet (CLI/testing only)
**Allowed states:** Executing OR explicit debug mode (not for normal UI usage)

Request payload:
```

{ "project_id": "uuid", "diffs": ["string"] }

```

Response result:
```

{ "applied": true, "rollback_point_id": "uuid" }

```

Emitted events:
- `DiffProposed` (optional)
- `LogEntry`
- `ErrorRaised` on rejection

---

### Build
**Allowed states:** Idle OR Executing (if plan step is build)

Request payload:
```

{ "project_id": "uuid", "configuration": "Debug|Release", "timeout_seconds": 300 }

```

Response result:
```

{ "exit_code": 0, "duration_ms": 0, "warnings": 0, "errors": 0 }

```

Emitted events:
- `Progress`
- `LogEntry`
- `ErrorRaised` on failure

---

### Preview
**Allowed states:** Idle OR Completed (never automatic; UI-triggered)

Request payload:
```

{ "project_id": "uuid", "timeout_seconds": 300 }

```

Response result:
```

{ "started": true }

```

Emitted events:
- `LogEntry`
- `ErrorRaised` on failure

---

### ExportDiagnostics
**Allowed states:** any

Request payload:
```

{

"project_id": "uuid",

"output_path": "string",

"include_debug": false,

"include_project_tree": false

}

```

Response result:
```

{ "bundle_path": "string" }

```

Emitted events:
- `Progress`
- `LogEntry`
- `ErrorRaised` on failure

---

# Events (V1) — Complete Table

## StateChanged
Payload:
```

{ "from": "Idle", "to": "Planning", "trigger": "GeneratePlan" }

```

Rules:
- MUST be emitted for every state transition.
- MUST be consistent with Orchestration State Machine.

## PlanProposed
Payload:
```

{

"plan": {

"id": "uuid",

"version": 1,

"status": "pending",

"estimated_tokens": 0,

"constraints": [],

"steps": [

{

"id": "uuid",

"order": 1,

"type": "file_create|file_modify|file_delete|build",

"target": "relative/path",

"description": "string",

"dependencies": []

}

]

}

}

```

Rules:
- MUST be emitted before any DiffProposed for that plan.

## DiffProposed
Payload:
```

{ "step_id": "uuid", "diff": "string" }

```

Rules:
- Diff string MUST be either:
  - exact `NO_CHANGES_REQUIRED`, or
  - a valid unified diff per diff contract.

## StepStarted
Payload:
```

{ "step_id": "uuid", "order": 1, "description": "string" }

```

## StepCompleted
Payload:
```

{ "step_id": "uuid", "ok": true, "duration_ms": 0 }

```

Rules:
- If ok=false, an ErrorRaised SHOULD also be emitted.

## Progress
Payload:
```

{ "phase": "planning|diff|apply|build|preview|rollback", "current": 3, "total": 10 }

```

Rules:
- Used for UI progress only; MUST NOT be required for correctness.

## LogEntry
Payload:
```

{

"level": "ERROR|WARN|INFO|DEBUG|TRACE",

"component": "Orchestrator|DiffParser|FileGateway|BuildExecutor|AIInterface",

"message": "string",

"correlation_id": "uuid"

}

```

Rules:
- MUST NOT include secrets.
- SHOULD include stable identifiers (plan_id, step_id) in structured context if needed.

## ErrorRaised
Payload:
```

{ "error": { "code": "VAL-004", "category": "Validation", "severity": "error", "message": "string", "technical_detail": "string", "recovery_path": "Modify", "retryable": true } }

```

Rules:
- MUST be emitted when a user-visible failure occurs.

---

## Cancellation and Timeouts (Hard Rules)
- Requests MAY include `timeout_ms`. If timeout occurs:
  - backend returns `ok=false` with IPC-008 (or aligned error code)
- Cancel is best-effort but MUST be deterministic:
  - MUST NOT interrupt atomic file writes
  - MUST NOT leave partial filesystem state
  - MUST transition through Cancelling and either return to Idle or Failed

---

## Compatibility and Versioning

### Version Format
- `ipc_version = MAJOR.MINOR` (string), example: `1.0`

### Compatibility Rules
- Same MAJOR is compatible:
  - receivers ignore unknown fields
  - UI ignores unknown events
- Different MAJOR is incompatible:
  - UI MUST refuse to connect

### Allowed MINOR changes
- MAY add optional fields
- MAY add new commands/events
- MAY add enum values only if unknown handling is safe

### Forbidden MINOR changes
- MUST NOT remove fields
- MUST NOT change meaning of existing fields
- MUST NOT change required/optional in a breaking way

### Unknown Handling
- Unknown command: backend returns `ok=false` with IPC-003
- Unknown event: UI ignores (may log IPC-004)
- Unknown field: ignore
- Unknown enum value:
  - fail-closed if affects safety/execution ordering
  - otherwise treat as unknown and surface

---

# Examples

## Example: Successful OpenProject (Good)
Request:
```

{ "ipc_version":"1.0","type":"request","request_id":"1111","sent_at":"2026-01-15T00:00:00Z","command":"OpenProject","payload":{"path":"D:\proj"} }

```

Response:
```

{ "ipc_version":"1.0","type":"response","request_id":"1111","correlation_id":"2222","sent_at":"2026-01-15T00:00:00Z","ok":true,"result":{"project_id":"3333","project_root":"D:\proj","detected_markers":[".sln"]},"error":null }

```

## Example: Bad response (Missing request_id) — MUST be treated as fatal
```

{ "ipc_version":"1.0","type":"response","correlation_id":"2222","sent_at":"...","ok":true,"result":{},"error":null }

```
UI action: raise IPC-001 and stop.

## Example: Event sequence violation — MUST be treated as fatal
If UI receives `seq=10` then `seq=12` (missing 11):
UI action: raise IPC-007 and stop execution for that correlation_id.

---

# Edge Cases (Required Behaviors)

## Duplicate request_id
- Backend MUST detect duplicates within an active session.
- Backend returns `ok=false` with IPC-006.
- UI must retry with a new request_id.

## Stale response arrives after timeout
- UI MUST ignore late responses for a timed-out request.
- Backend MUST still treat the request as completed once it responded; it MUST NOT retroactively change state without emitting events.

## Cancel during atomic apply
- Backend MUST finish the atomic boundary.
- Backend MUST then transition to Cancelling and rollback if needed.
- Backend MUST emit StateChanged events for these transitions.

## Unknown ipc_version
- Backend MUST return `ok=false` with IPC-002.
- UI MUST refuse to continue.