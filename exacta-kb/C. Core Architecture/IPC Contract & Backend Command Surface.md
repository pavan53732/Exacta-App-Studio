# IPC Contract & Backend Command Surface

## Purpose
Define the versioned IPC contract between UI and backend.

## Scope
- Commands (requests)
- Events (push)
- Progress reporting
- Cancellation and timeouts
- Compatibility and versioning rules

## Requirements
- MUST be versioned.
- MUST be deterministic.
- MUST be backward compatible within a defined policy.
- MUST be fail-closed: unknown command/event/schema version MUST be rejected with a structured error.
- MUST be correlation-id based: every request and all derived events must be traceable.

## Command Catalog (V1)
- OpenProject
- CloseProject
- ExtractIntent
- GeneratePlan
- ValidatePlan
- ApprovePlan
- RejectPlan
- ExecutePlan
- Pause
- Resume
- Cancel
- ApplyDiffSet
- Build
- Preview
- ExportDiagnostics

## Event Catalog (V1)
- StateChanged
- PlanProposed
- DiffProposed
- StepStarted
- StepCompleted
- LogEntry
- ErrorRaised
- Progress

---

## Wire Format

### Transport
IPC transport is implementation-specific (Tauri invoke, stdio, named pipe, etc.).
This document defines the **message envelope** and payload schemas that MUST be preserved across transports.

### Encoding
- All IPC messages MUST be UTF-8 JSON.
- The system MUST NOT use non-JSON ad-hoc text protocols for commands/events in production.

### Message Types
The IPC stream consists of:
- **Request** messages: UI → backend
- **Response** messages: backend → UI (direct response to a request)
- **Event** messages: backend → UI (push; not necessarily tied to a request)
- **Ack** messages: backend → UI (optional small confirmation for event receipt if transport needs it)

### Common IDs (Required)
- `request_id` MUST be a UUID generated by the caller (UI) for each request.
- `correlation_id` MUST be a UUID generated by the backend per "operation" (one user intent / one plan execution).
- The backend MUST echo `request_id` in the corresponding response.
- Events emitted as part of a request MUST include both `request_id` and `correlation_id`.

### Base Envelopes

#### Request Envelope (UI → backend)
```

{

"ipc_version": "1.0",

"type": "request",

"request_id": "uuid",

"sent_at": "ISO-8601",

"command": "OpenProject",

"payload": {}

}

```

#### Response Envelope (backend → UI)
```

{

"ipc_version": "1.0",

"type": "response",

"request_id": "uuid",

"correlation_id": "uuid",

"sent_at": "ISO-8601",

"ok": true,

"result": {},

"error": null

}

```

#### Event Envelope (backend → UI)
```

{

"ipc_version": "1.0",

"type": "event",

"event": "StateChanged",

"event_id": "uuid",

"sent_at": "ISO-8601",

"request_id": "uuid-or-null",

"correlation_id": "uuid",

"payload": {}

}

```

### Error Object (Canonical)
All failures MUST use this structure (even if UI shows a friendly message):
```

{

"code": "ST-001",

"category": "State",

"severity": "fatal",

"message": "Invalid state transition: Planning → Executing",

"technical_detail": "Expected AwaitingApproval before Executing.",

"recovery_path": "Restart",

"retryable": false

}

```

### Determinism Rules (IPC-Level)
- Given the same starting state and the same sequence of requests, the backend MUST emit the same sequence of state transitions and gate decisions.
- Event ordering MUST be stable:
  - `StateChanged` MUST be emitted before any events that are only valid in the new state.
  - `StepStarted` MUST precede `StepCompleted` for the same step.
- The backend MUST NOT emit "implicit success" events. Every significant transition MUST be explicit.

---

## Command Schemas (V1 Minimal)

> Note: Payloads are intentionally minimal; expand later without breaking compatibility by adding optional fields only.

### OpenProject
**Request payload**
```

{ "path": "string" }

```
**Response result**
```

{ "project_id": "uuid", "project_root": "string", "detected_markers": ["string"] }

```

### CloseProject
**Request payload**
```

{ "project_id": "uuid" }

```
**Response result**
```

{ "closed": true }

```

### ExtractIntent
**Request payload**
```

{ "project_id": "uuid", "user_input": "string" }

```
**Response result**
```

{

"intent": {

"id": "uuid",

"type": "CreateProject|AddFeature|FixBug|BuildPackage|UnknownIntent",

"confidence": 0.0,

"raw_input": "string",

"target": { "files": ["string"], "symbols": ["string"], "description": "string" },

"constraints": [ { "type": "MUST|MUST_NOT|PREFER", "description": "string", "scope": "string" } ],

"timestamp": "ISO-8601"

}

}

```

### GeneratePlan
**Request payload**
```

{ "project_id": "uuid", "intent_id": "uuid" }

```
**Response result**
```

{ "plan_id": "uuid", "version": 1, "status": "pending" }

```
Plan details MUST be delivered via `PlanProposed` event (so UI can stream/display progressively).

### ValidatePlan
**Request payload**
```

{ "project_id": "uuid", "plan_id": "uuid" }

```
**Response result**
```

{ "valid": true, "violations": [] }

```

### ApprovePlan / RejectPlan
**Request payload**
```

{ "project_id": "uuid", "plan_id": "uuid" }

```
**Response result**
```

{ "plan_id": "uuid", "status": "approved" }

```

### ExecutePlan
**Request payload**
```

{ "project_id": "uuid", "plan_id": "uuid" }

```
**Response result**
```

{ "execution_id": "uuid" }

```

### Pause / Resume / Cancel
**Request payload**
```

{ "project_id": "uuid", "execution_id": "uuid" }

```
**Response result**
```

{ "execution_id": "uuid", "status": "paused|executing|cancelling" }

```

### ApplyDiffSet
Used internally by execution, but exposed for CLI/testing.
**Request payload**
```

{ "project_id": "uuid", "diffs": ["string"] }

```
**Response result**
```

{ "applied": true, "rollback_point_id": "uuid" }

```

### Build
**Request payload**
```

{ "project_id": "uuid", "configuration": "Debug|Release", "timeout_seconds": 300 }

```
**Response result**
```

{ "exit_code": 0, "duration_ms": 0, "warnings": 0, "errors": 0 }

```

### Preview
**Request payload**
```

{ "project_id": "uuid", "timeout_seconds": 300 }

```
**Response result**
```

{ "started": true }

```

### ExportDiagnostics
**Request payload**
```

{ "project_id": "uuid", "output_path": "string", "include_debug": false, "include_project_tree": false }

```
**Response result**
```

{ "bundle_path": "string" }

```

---

## Event Schemas (V1 Minimal)

### StateChanged
```

{ "from": "Idle", "to": "Planning", "trigger": "GeneratePlan" }

```

### PlanProposed
```

{

"plan": {

"id": "uuid",

"version": 1,

"status": "pending",

"estimated_tokens": 0,

"constraints": [],

"steps": [

{

"id": "uuid",

"order": 1,

"type": "file_create|file_modify|file_delete|build",

"target": "relative/path",

"description": "string",

"dependencies": []

}

]

}

}

```

### DiffProposed
```

{ "step_id": "uuid", "diff": "string" }

```

### StepStarted / StepCompleted
```

{ "step_id": "uuid", "order": 1, "description": "string" }

```

```

{ "step_id": "uuid", "ok": true, "duration_ms": 0 }

```

### Progress
```

{ "phase": "planning|diff|apply|build|preview", "current": 3, "total": 10 }

```

### LogEntry
```

{ "level": "INFO", "component": "Orchestrator", "message": "string", "correlation_id": "uuid" }

```

### ErrorRaised
```

{ "error": { "code": "VAL-004", "category": "Validation", "severity": "error", "message": "string", "technical_detail": "string", "recovery_path": "Modify", "retryable": true } }

```

---

## Cancellation and Timeouts (IPC Rules)
- Every request MAY include an optional `timeout_ms`.
- If a request times out, the backend MUST return a Response with `ok=false` and a timeout error code.
- Cancel MUST be best-effort and deterministic:
  - It MUST NOT interrupt atomic file writes mid-write.
  - It MAY wait until the current atomic boundary, then transition to Cancelling.

---

## Versioning

### Version Format
- `ipc_version` is a string: `MAJOR.MINOR`
  - Example: `1.0`

### Compatibility Rules
- Same MAJOR means compatible:
  - A `1.x` UI MUST be able to communicate with a `1.y` backend if:
    - it only uses fields/commands defined in `1.x`
    - it tolerates additional fields it does not understand
- Different MAJOR means incompatible:
  - UI MUST refuse to connect if MAJOR differs.

### Forward/Backward Compatibility Requirements
- New MINOR versions MAY:
  - add optional fields
  - add new commands/events
  - add new enum values ONLY if older clients can treat them as "unknown" safely
- New MINOR versions MUST NOT:
  - remove fields
  - change field meanings
  - change required/optional status in a breaking way

### Unknown Handling
- Unknown command: backend returns `ok=false` with error `CFG-002` or a dedicated IPC error code.
- Unknown event: UI ignores it.
- Unknown field: receiver ignores it.
- Unknown enum value: receiver MUST fail-closed if it affects safety or execution ordering; otherwise treat as "unknown" and surface.

### Schema Versioning
If/when JSON schemas are formalized:
- Each command/event MUST have a schema ID.
- Schema IDs MUST be versioned and tied to `ipc_version`.

---

## Transport Framing Rules (Tauri `invoke`) — V1

## Purpose
Define how the IPC contract is carried over Tauri's `invoke` boundary while preserving determinism, safety, and traceability.

## Model
- UI calls backend using `invoke(command, payload)`.
- Backend returns a **single response** per invoke call.
- Streaming is achieved by emitting **events** from backend to UI (Tauri event channel).

## Mapping: IPC Envelopes → Tauri

### Requests
- Each IPC **Request** maps to a single Tauri `invoke`.
- `command` maps to the Tauri command name.
- `payload` maps to the invoke payload.

The invoke payload MUST include:
- `ipc_version`
- `request_id`
- `sent_at`
- command-specific payload fields

### Responses
Each invoke MUST return a Response-shaped JSON object:
- `ipc_version`
- `type = "response"`
- `request_id`
- `correlation_id`
- `ok`
- `result` or `error`

UI MUST treat a non-conforming response as a **fatal protocol violation**.

### Events
Backend emits events using a single stream name (recommended):
- `exacta:event`

Each emitted event payload MUST conform to the IPC Event Envelope:
- `ipc_version`
- `type = "event"`
- `event`
- `event_id`
- `sent_at`
- `request_id` (nullable)
- `correlation_id`
- `payload`

## Message Boundaries
- Each `invoke` call + returned JSON is an atomic message boundary.
- Each emitted event is an atomic message boundary.
No additional framing is required.

## Ordering Guarantees
- For a given `correlation_id`, backend MUST emit events in deterministic order.
- If transport reorders events, UI MUST reorder by `sent_at` and (recommended) `seq`.

### Optional `seq` Field (Recommended)
Backend MAY include:
- `seq`: integer, monotonically increasing per `correlation_id`

If present, UI SHOULD order primarily by `(correlation_id, seq)`.

## Error Handling Rules
- Invoke-level failure (panic, serialization failure, internal exception) MUST be converted into:
  - `type="response"`, `ok=false`, and structured `error`.
- Backend MUST NOT return raw stack traces to UI by default.
- UI MUST surface a protocol error if:
  - `ipc_version` missing/mismatched
  - `request_id` missing
  - response missing both `result` and `error`

## Backpressure and Rate Limits
- UI MUST NOT start a new plan execution while another execution is in progress (unless explicitly supported).
- Backend MAY reject requests with Resource or State error codes when overloaded.
- Backend MUST remain responsive to `Cancel` best-effort, respecting atomic boundaries.

## Security and Isolation
- IPC MUST NOT expose API keys or credentials.
- UI MUST NOT send secrets via invoke payloads.
- Backend MUST treat all UI-provided strings as untrusted input.