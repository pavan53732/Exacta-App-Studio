<prompt.md>

<M1. artifact schema>
M1. artifact schema
M2. cycle overview
M3. interaction schema
M4. current project scope
M5. organized artifacts list
M6. cycles
M7. Flattened Repo
</M1. artifact schema>

<M2. cycle overview>
Current Cycle 0 - Project Initialization
</M2. cycle overview>

<M3. Interaction Schema>

# Artifact A52.2: DCE - Interaction Schema Source

# Date Created: C156

# Author: AI Model & Curator

# Updated on: C6 (Clarify closing tag and add curator activity section)

- **Key/Value for A0:**
- **Description:** The canonical source text for the M3. Interaction Schema, which is injected into all generated prompts.
- **Tags:** documentation, process, interaction schema, source of truth

## Interaction Schema Text

1.  Artifacts are complete, individual texts enclosed in `<xmltags>`. To ensure consistent parsing by the DCE extension, all file artifacts **must** be enclosed in `<file path="path/to/file.ts">...</file_artifact>` tags. The path must be relative to the workspace root. **The closing tag must be exactly `</file_artifact>`.** Do not use the file path in the closing tag (e.g., `</file path="...">` is incorrect). Do not write the closing tag as `</file>` or `</file_path>`. Only `</file_artifact>` will parse successfully.

2.  Our Document Artifacts serve as our `Source of Truth` throughout multiple cycles. As such, over time, as issues occur, or code repeatedly regresses in the same way, seek to align our `Source of Truth` such that the Root Cause of such occurances is codified so that it can be avoided on subsequent cycles visits to those Code artifacts.

3.  Please output entire Document or Code artifacts. Do not worry about Token length. If your length continues for too long, and you reach the 600 second timeout, I will simply incorporate the work you did complete, and we can simply continue from where you left off. Better to have half of a solution to get started with, than not to have it. **Preference is for larger, more complete updates over smaller, incremental ones to align with the human curator's parallel processing workflow.** The human curator often sends the same prompt to multiple AI instances simultaneously and selects the most comprehensive response as the primary base for the next cycle, using other responses as supplementary information. Providing more complete updates increases the likelihood of a response being selected as the primary base.

4.  Do not output artifacts that do not require updates in this cycle. (Eg. Do not do this: // Updated on: Cycle 1040 (No functional changes, only cycle header))

5.  **Critical: `flattened_repo_v2.txt` contains all project files. Output updated *individual* files that are part of it (like `<src/state/coreStore.ts>...`). However, do **NOT** output the surrounding Artifact container tags (`<flattened_repo_v2.txt>...</flattened_repo_v2.txt>`) or any auto-generated metadata sections within it (like the Total Files summary, Top 10 list, or the `<files list>` section) which are created by the `flatten.js` script.**
    5.1. `flattened_repo_v2.txt` is a copy of the codebase, generated by a script; assume its an accurate representation of the existing codebase, but not necessarily a 'source of truth' like we treat our documents as, our codebase is a living artifact, documents, while we can update them, should be considered less transient.
    5.2. **`.local` File Convention:** To manage token count, some large data files (e.g., `researchNodes.ts`) may be represented by a truncated `.local.ts` version in the context. This version contains the essential structure and a few examples. If the full content of a file is required for a task (e.g., a comprehensive data refactor or fixing a bug related to a specific entry), explicitly state this need in your summary of actions and request that the curator swap the `.local.ts` file with the full `.ts` version in the `files_list.txt` for the subsequent cycle.

6.  remember to output complete artifacts without placeholders, im taking your output, putting it in winmerge, and confirming we arent losing data in the update. when you provide placeholders, my cursory review turns into a meticulous file parsing, taking me from what is 5 seconds per artifact to upwards of 5 minutes, only to realize that the output is actually un-parseable, due to the nature of relativity, as the theory of relativity also applies to code. if you give me a code snippet, and do not give me the code surrounding that snippet, i do not know where that code should go. by providing the complete file, on the other hand, i can put it in a diff, see easily what was altered, and if anything was accidentally omitted or lost, i can be sure that it's retained.

7.  **Update documentation before writing code.** document artifacts are like our project readme files, our source of truth. they are our blueprints. they guide the code we write. when we realize we need to alter our approach or invent new game mechanics, we update the source of truth first, cause english is easy and flexible, then we codify that.

8.  this query is part of a larger software engineering project

9.  After you complete delivery on a code artifact, review it to make sure you did not miss any intermediary files. for instance, if we have a DevelopmentSystem.ts, using the componentData.ts, which is displaying on the ComponentProductionTab.tsx. But then theres also still a DevPanel.tsx file that is in-between that _could_, but shouldnt, get overlooked.

10. If you are deciding where to put a particular piece of code or function, and due to its nature, there are one or more candidate files that it could be placed in, choose the smaller file (in tokens).

11. Begin your response with a course of action and end with a review of your work, surface any self corrections in the summary of changes for the subsequent cycle.

12. do not underestimate how much you can accomplish in a given cycle; you'd only accomplish handicapping yourself. (Eg. you've authored this whole thing with just my guidance. good job, keep it up.)

13. Not as relevant for this project: **Log State Button:** The 'Log State' button in the `DevInfoOverlay` is a dynamic debugging tool. Modify the `triggerDebugLogs` action in `uiStore.ts` to output specific state information relevant to the current bug being investigated. **See A85 (Logging Guide) for usage details.**

14. Not as relevant for this project: **Regression Case Studies:** Use Artifact A106 to document persistent or complex bugs and their resolutions. Add entries _after_ a fix is confirmed to codify the RCA and solution, preventing future regressions.

15. Include in your cycle summary, a short list of files you've updated. This makes it easy for my reviews.

16. if you seem to have spare time in a cycle, see if you can spot any particular file with excessive levels of comments or logging that seems extensive and for troubleshooting an error that has since been resolved, see to it to clean those files but preserve their functionalities. im just looking to shave off excess tokens wherever possible in the master_content.txt file.

17. if you see `(No change from C850)` such language, it's data loss. there was supposed to be actual language behind that placeholder, but in one iteration (C850, in this case) you had provided a placeholder, and i 'missed it' and did not capture the initial information. you either need to deliver the placeholder in such a way as i can easily press the left arrow instead of the rigth arrow in winmerge to not accept that part, but to also not have winmerge confuse it with the rest, otherwise i must manually parse the information. when the process is a single keystroke, i can manage it quickly enough. when we remove that ability because you provided me data in a format that has placeholders AND the placeholders do not parse within winmerge such that it removes the benefit winmerge is adding, then we have our problem. when you see this, try to correct it using whatever current relevant context you have.

18. basically, you should not worry about brevity, because when you go too long, your response gets interrupted by the system anyway. its better that the products you do deliver are all complete except for the last one, rather than you delivering all incomplete products, including the last one. does that make sense?

19. remember, do not stop outputting for the reason of preventing a potential artifact interruption mid-output. you actually end up stopping yourself from producting two or three additional files before you actually get interrupted. what i mean is, in the outputs where you do not do this, you produce for 500 seconds, producing 7-9 files, and only the last one is interrupted and unusable. compared to when you stop yourself prematurely, for the reason stated, and you produce for 180 seconds and provide maybe 3-4 files. even with the -1, producing as much as you can still outperforms the alternative.

20. This is a misaligned statement: `// (For full history, see master_content.txt)` because your changes get rolled into master_content.txt. therefore, if you remove the history, then when your updates are rolled in, they will remove the full history. understand? after a while, the history is not relevant and can be rolled out, for a while, it ought to stay. you can see what we're working on + the current cycle and make this determination.

21. Each time we create a new documentation artifact, lets also create the key/value pairs needed for me to add it into our Master Artifact List. they can simply be added into the new artifact itself and ill make the new entry in A0. this will solve for me manually generating a description and tag for each new documentation artifact. also, dont place `/` in the title/name of a documentation artifact. VSCode treats it as a folder separator.
    21.1. when creating a new documentation artifact, also just update the master artifacts list itself.

22. **New: Curator Activity Section:** If you need the human curator to perform an action that you cannot (e.g., delete a file, run a specific command), include these instructions in a dedicated `<curator_activity>...</curator_activity>` section in your response.

# Artifact A52.1: DCE - Parser Logic and AI Guidance

# Date Created: C155

# Author: AI Model & Curator

# Updated on: C14 (Make file tag parsing more flexible)

- **Key/Value for A0:**
- **Description:** Provides the literal source code for the response parser and explicit instructions to the AI on how to format its output to ensure successful parsing.
- **Tags:** documentation, process, parsing, metainterpretability, source of truth

## 1. Overview & Goal (Metainterpretability)

This document is included in every prompt to provide you with direct insight into how your responses are parsed. By understanding the exact logic used to interpret your output, you can structure your responses to be perfectly machine-readable, ensuring a smooth and reliable workflow.

The goal is to eliminate parsing failures caused by unexpected formatting. Adhering to this guide is a critical part of the interaction schema.

## 2. The Parser's Source Code

The following TypeScript code is the complete and exact logic used by the Parallel Co-Pilot Panel to parse your responses. It looks for specific XML tags to separate the summary, course of action, and file blocks.

````typescript
// src/client/utils/response-parser.ts
import { ParsedResponse, ParsedFile } from '@/common/types/pcpp.types';

const SUMMARY_REGEX = /<summary>([\s\S]*?)<\/summary>/;
const COURSE_OF_ACTION_REGEX = /<course_of_action>([\s\S]*?)<\/course_of_action>/;
const CURATOR_ACTIVITY_REGEX = /<curator_activity>([\s\S]*?)<\/curator_activity>/;
// C14 Update: More flexible closing tag matching
const FILE_TAG_REGEX = /<file path="([^"]+)">([\s\S]*?)(?:<\/file_path>|<\/file>|<\/filepath>|<\/file_artifact>)/g;
const CODE_FENCE_START_REGEX = /^\s*```[a-zA-Z]*\n/;

export function parseResponse(rawText: string): ParsedResponse {
    const fileMap = new Map<string, ParsedFile>();
    let totalTokens = 0;

    let processedText = rawText.replace(/\\</g, '<').replace(/\\>/g, '>').replace(/\\_/g, '_');

    const tagMatches = [...processedText.matchAll(FILE_TAG_REGEX)];

    if (tagMatches.length === 0 && processedText.includes('<file path')) {
        const summary = `**PARSING FAILED:** Could not find valid \`<file path="...">...</file_artifact>\` (or similar) tags. The response may be malformed or incomplete. Displaying raw response below.\n\n---\n\n${processedText}`;
        return { summary, courseOfAction: '', filesUpdated: [], files: [], totalTokens: Math.ceil(processedText.length / 4) };
    }

    for (const match of tagMatches) {
        const path = (match?. ?? '').trim();
        let content = (match?. ?? '');

        if (path) {
            content = content.replace(CODE_FENCE_START_REGEX, '');
            // C14 Update: Add new tags to the removal list
            const patternsToRemove = [`</file_artifact>`, `</file_path>`, `</filepath>`, `</file>`, `</${path}>`, '```', '***'];
            let changed = true;
            while(changed) {
                const originalContent = content;
                for (const pattern of patternsToRemove) {
                    if (content.trim().endsWith(pattern)) {
                        content = content.trim().slice(0, -pattern.length);
                    }
                }
                if (content === originalContent) { changed = false; }
            }
            content = content.trim();
            const tokenCount = Math.ceil(content.length / 4);
            fileMap.set(path, { path, content, tokenCount });
        }
    }

    const finalFiles = Array.from(fileMap.values());
    totalTokens = finalFiles.reduce((sum, file) => sum + file.tokenCount, 0);

    const summaryMatch = processedText.match(SUMMARY_REGEX);
    const courseOfActionMatch = processedText.match(COURSE_OF_ACTION_REGEX);
    const curatorActivityMatch = processedText.match(CURATOR_ACTIVITY_REGEX);

    const summary = (summaryMatch?.[1] ?? 'Could not parse summary.').trim();
    const courseOfAction = (courseOfActionMatch?.[1] ?? 'Could not parse course of action.').trim();
    const curatorActivity = (curatorActivityMatch?.[1] ?? '').trim();

    const filesUpdatedList = finalFiles.map(f => f.path);

    if (finalFiles.length === 0 && !summaryMatch && !courseOfActionMatch && !curatorActivityMatch) {
        return { summary: processedText, courseOfAction: '', filesUpdated: [], files: [], totalTokens: Math.ceil(processedText.length / 4) };
    }

    return {
        summary,
        courseOfAction,
        curatorActivity,
        filesUpdated: [...new Set(filesUpdatedList)],
        files: finalFiles,
        totalTokens,
    };
}
````

## 3. Critical Instructions for Formatting Your Response

To guarantee successful parsing, every response **must** follow this structure:

1.  **Summary:** Your high-level analysis and plan must be enclosed in `<summary>...</summary>` tags.
2.  **Course of Action:** Your point-by-point plan must be enclosed in `<course_of_action>...</course_of_action>` tags.
3.  **File Blocks:** Every file you generate must be enclosed in `<file path="..."></file_artifact>` tags (or a similar valid closing tag). The parser uses a global regex (`/g`) to find all occurrences of this pattern. The closing tag can be `</file_artifact>`, `</file_path>`, `</filepath>`, or `</file>`.

### Canonical Example:

```
<summary>
I have analyzed the request. My course of action is to update the main component and its corresponding stylesheet.
</summary>

<course_of_action>
1.  **Update `view.tsx`:** Add a new state variable and a button.
2.  **Update `view.scss`:** Add styling for the new button.
</course_of_action>

<file path="src/client/views/my-view/view.tsx">
// (Canonical Example) Full content of the view.tsx file...
</file_artifact>

<file path="src/client/views/my-view/view.scss">
/* (Canonical Example) Full content of the view.scss file... */
</file_artifact>
```

</M3. Interaction Schema>

<M4. current project scope>
I'll help you implement the missing components to complete the Windows-only app builder implementation. Let's address each of the identified issues:

1. **Create the missing Tauri-specific system prompt**
2. **Update the main system prompt to conditionally append stack-specific prompts**
3. **Verify and potentially enhance the Guardian schema extensions**

Let's start by creating the missing Tauri-specific system prompt:

It seems I don't have direct write access to the filesystem. Let me use the appropriate tool to create the file:

It seems I don't have access to the filesystem write tools. Let me try a different approach by checking if I can access the guardian types to see what schema extensions exist:

Let me try to read the existing files to see the current state of the system and identify the exact changes needed:

I apologize, it seems I don't have access to the filesystem tools. Let me try to approach this differently by providing the code that needs to be implemented to address the missing components.

Based on the windows-only-app-builder-plan.md that I read earlier, I need to implement three missing components:

1. **Missing Tauri-specific system prompt** - Let me provide the code for this:

```typescript
// src/prompts/system/tauri_prompt.ts
// System prompt for Tauri desktop development

export const TAURI_PROMPT = `
# Tauri Desktop Development

You are a Tauri expert for building secure, lightweight desktop applications with Rust and web technologies.

## Tech Stack
- Tauri v2 (Rust + WebView2)
- Frontend: vanilla JS or framework of choice
- Backend: Rust
- WebView2 on Windows

## Available Dyad Tags
- <dyad-write path="src-tauri/src/main.rs"> - Write Rust backend code
- <dyad-write path="src-tauri/tauri.conf.json"> - Tauri configuration
- <dyad-write path="src/index.html"> - Frontend HTML/JS
- <dyad-command type="rebuild"></dyad-command> - Rebuild the app

## Project Structure
AppName/
‚îú‚îÄ‚îÄ src/                         // Frontend code
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îú‚îÄ‚îÄ main.js
‚îÇ   ‚îî‚îÄ‚îÄ styles.css
‚îú‚îÄ‚îÄ src-tauri/                   // Rust backend
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.rs              // Main Rust entry
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml               // Rust dependencies
‚îÇ   ‚îî‚îÄ‚îÄ tauri.conf.json          // Tauri config
‚îî‚îÄ‚îÄ package.json

## Rust Tauri Commands
Define commands in main.rs:
\`\`\`rust
#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}!", name)
}
\`\`\`

Invoke from frontend:
\`\`\`javascript
import { invoke } from '@tauri-apps/api/core';
const response = await invoke('greet', { name: 'World' });
\`\`\`

## Security Best Practices
- Use Tauri's permission system
- Validate all inputs in Rust commands
- Use capability-based security
- Minimize frontend privileges

## Security Notice
All commands execute through Dyad's secure ExecutionKernel with:
- Network policy enforcement
- Memory limits (4GB for builds)
- Timeout protection (10 min max)
- Capability-based access control

Generate secure, fast Tauri apps with proper separation between frontend and backend.
`;
```

2. **Integration of runtime prompts in the main system prompt** - Here's the updated constructSystemPrompt function:

```typescript
// Add these imports to the top of system_prompt.ts
import { DOTNET_WPF_PROMPT } from "./system/dotnet_wpf";
import { DOTNET_WINFORMS_PROMPT } from "./system/dotnet_winforms";
import { DOTNET_WINUI3_PROMPT } from "./system/dotnet_winui3";
import { TAURI_PROMPT } from "./system/tauri_prompt";

// Update the constructSystemPrompt function to conditionally append prompts
export const constructSystemPrompt = ({
  aiRules,
  chatMode = "build",
  enableTurboEditsV2,
  themePrompt,
  readOnly,
  basicAgentMode,
  stackType = "react",
  runtimeProvider = "node",
}: {
  aiRules: string | undefined;
  chatMode?: "build" | "ask" | "agent" | "local-agent" | "plan";
  enableTurboEditsV2: boolean;
  themePrompt?: string;
  /** If true, use read-only mode for local-agent (ask mode with tools) */
  readOnly?: boolean;
  /** If true, use basic agent mode (free tier with limited tools) */
  basicAgentMode?: boolean;
  stackType?: string;
  runtimeProvider?: string;
}) => {
  if (chatMode === "plan") {
    return constructPlanModePrompt(aiRules, themePrompt);
  }

  if (chatMode === "local-agent") {
    return constructLocalAgentPrompt(aiRules, themePrompt, {
      readOnly,
      basicAgentMode,
    });
  }

  let systemPrompt = getSystemPromptForChatMode({
    chatMode,
    enableTurboEditsV2,
  });
  systemPrompt = systemPrompt.replace(
    "[[AI_RULES]]",
    aiRules ?? DEFAULT_AI_RULES,
  );

  // Append theme prompt if provided
  if (themePrompt) {
    systemPrompt += "\n\n" + themePrompt;
  }

  // NEW: Append stack-specific prompts
  if (runtimeProvider === "dotnet") {
    systemPrompt += "\n\n" + DOTNET_WPF_PROMPT;
  } else if (runtimeProvider === "tauri") {
    systemPrompt += "\n\n" + TAURI_PROMPT;
  }

  return systemPrompt;
};
```

3. **For the Guardian schema extensions**, I need to check the current guardian types file. Based on the plan, the guardian.ts file should have the following updates:

```typescript
// Update src/ipc/types/guardian.ts with the schema extensions mentioned in the plan

import { z } from "zod";

export const CreateJobRequestSchema = z.object({
  jobName: z.string(),
  memoryLimitBytes: z.number().optional(),
  cpuRatePercent: z.number().min(1).max(100).optional(),
  activeProcessLimit: z.number().optional(),
  killProcessesOnJobClose: z.boolean().default(true),
  // NEW: Zero-Trust extensions
  networkPolicy: z.enum(["blocked", "allowed", "local-only"]).optional(),
  diskQuotaBytes: z.number().optional(),
});

// NEW: spawnInJob Contract for secure process spawning
export const spawnInJob = defineContract({
  channel: "guardian:spawn-in-job",
  input: z.object({
    jobId: z.string(),
    command: z.string(),
    args: z.array(z.string()),
    cwd: z.string(),
    env: z.record(z.string()).optional(),
    token: z.string().optional(),
  }),
  output: z.object({
    success: z.boolean(),
    pid: z.number().optional(),
    error: z.string().optional(),
  }),
});
```

These implementations will complete the missing components from the Windows-only app builder plan:

1. Creating the missing Tauri system prompt
2. Integrating all runtime-specific prompts into the main system prompt construction
3. Ensuring the Guardian schema extensions are properly implemented

Once these changes are made, the Windows-only app builder will be fully implemented according to the plan.
</M4. current project scope>

<M5. organized artifacts list>

# No artifacts exist yet.

</M5. organized artifacts list>

<M6. Cycles>
<Cycle 0>
<Cycle Context>
Review the user's project scope in M4. Your task is to act as a senior project architect and generate a starter set of planning and documentation artifacts for this new project.

**CRITICAL INSTRUCTIONS:**

1.  You have been provided with a set of best-practice templates for software engineering documentation in the <Static Context> section.
2.  Your primary goal is to **select the most relevant templates** and generate project-specific versions of them.
3.  **PRIORITIZE ESSENTIAL GUIDES:** You **MUST** generate artifacts based on "T14. Template - GitHub Repository Setup Guide.md" and "T7. Template - Development and Testing Guide.md". These are mandatory for the user to begin their project.
4.  Generate a Master Artifact List (A0) and at least two other core planning documents (e.g., Project Vision, Technical Scaffolding Plan).
5.  **DO NOT** generate any code files (e.g., .ts, .tsx, .js) in this initial cycle. The focus is on planning and documentation only.
    </Cycle Context>
    <Static Context>
    <!-- START: Project Templates -->
    <T7. Template - Development and Testing Guide.md>
    <!--
      IMPORTANT AI INSTRUCTION:
      When generating a file based on this template, you MUST wrap the entire file's content
      in <file path="src/Artifacts/[ProjectName]-A7-Dev-and-Testing-Guide.md"></file_artifact> tags.
    -->

# Artifact T7: Template - Development and Testing Guide

# Date Created: C139

# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A generic template for a development and testing guide.
- **Tags:** template, cycle 0, documentation, project setup

## 1. Purpose

This guide provides the standard procedure for running, debugging, and testing the **[Your Project Name]** application locally.

## 2. Development Workflow

### Step 1: Install Dependencies

Ensure all project dependencies are installed using npm.

```bash
npm install
```

### Step 2: Start the Development Server

To compile the code and watch for changes, run the following command:```bash
npm run watch

````
This will start the development server and automatically recompile your code when you save a file.

### Step 3: Running the Application

[Describe the specific steps to launch the application. For a VS Code extension, this would involve pressing F5 to launch the Extension Development Host. For a web app, it would be opening a browser to `http://localhost:3000`.]

### Step 4: Debugging

You can set breakpoints directly in your source code. [Describe how to attach a debugger. For a VS Code extension, this is automatic when launched with F5.]

## 3. Testing

The project is configured with a testing framework. To run the test suite, use the following command:
```bash
npm run test
````

This will execute all test files located in the project and report the results to the console.
</T7. Template - Development and Testing Guide.md>

<T14. Template - GitHub Repository Setup Guide.md>

<!--
  IMPORTANT AI INSTRUCTION:
  When generating a file based on this template, you MUST wrap the entire file's content
  in <file path="src/Artifacts/A14. [Project Name] - GitHub Repository Setup Guide.md">...</file_artifact> tags.
-->

# Artifact T14: [Project Name] - GitHub Repository Setup Guide Template

# Date Created: C152

# Author: AI Model & Curator

# Updated on: C160 (Add Sample Development Workflow section)

- **Key/Value for A0:**
- **Description:** A generic template for a guide on setting up a new project with Git and GitHub, including a sample workflow.
- **Tags:** template, cycle 0, git, github, version control, workflow

## 1. Overview

This guide provides the necessary commands to turn your local project folder into a Git repository, link it to a new repository on GitHub, and outlines a sample workflow for using Git alongside the Data Curation Environment (DCE).

## 2. Prerequisites

- You have `git` installed on your machine.
- You have a GitHub account.

## 3. Step-by-Step Setup

### Step 1: Create a New Repository on GitHub

1.  Go to [github.com](https://github.com) and log in.
2.  In the top-right corner, click the `+` icon and select **"New repository"**.
3.  **Repository name:** Enter a name for your project (e.g., `my-new-project`).
4.  **Description:** (Optional) Provide a brief description of your project.
5.  Choose **"Private"** or **"Public"**.
6.  **IMPORTANT:** Do **not** initialize the repository with a `README`, `.gitignore`, or `license`. We will be pushing our existing files, and this will prevent conflicts.
7.  Click **"Create repository"**.

GitHub will now show you a page with command-line instructions. We will use the section titled **"...or push an existing repository from the command line"**.

### Step 2: Initialize Git in Your Local Project

Open a terminal and navigate to your project's root directory. Then, run the following commands one by one.

1.  **Initialize the repository:**

    ```bash
    git init
    ```

2.  **Add all existing files:**

    ```bash
    git add .
    ```

3.  **Create the first commit:**

    ```bash
    git commit -m "Initial commit"
    ```

4.  **Rename the default branch to `main`:**
    ```bash
    git branch -M main
    ```

### Step 3: Link and Push to GitHub

1.  **Add the remote repository:** Replace the placeholder URL with the one from your GitHub repository page.

    ```bash
    git remote add origin https://github.com/YOUR_USERNAME/YOUR_REPOSITORY.git
    ```

2.  **Push your local `main` branch to GitHub:**
    ```bash
    git push -u origin main
    ```

After these commands complete, refresh your GitHub repository page. You should see all of your project files.

## 4. Sample Development Workflow with DCE and Git

Git is a powerful tool for managing the iterative changes produced by the DCE. It allows you to quickly test an AI's proposed solution and revert it cleanly if it doesn't work, without losing your place.

### Step 1: Start with a Clean State

Before starting a new cycle, ensure your working directory is clean. You can check this with `git status`. All your previous changes should be committed.

### Step 2: Generate a Prompt and Get Responses

Use the DCE to generate a `prompt.md` file. Use this prompt to get multiple responses (e.g., 4 to 8) from your preferred AI model.

### Step 3: Paste and Parse

Paste the responses into the Parallel Co-Pilot Panel and click "Parse All".

### Step 4: Accept and Test

1.  Review the responses and find one that looks promising.
2.  Select that response and use the **"Accept Selected Files"** button to write the AI's proposed changes to your workspace.
3.  Now, compile and test the application. Does it work? Does it have errors?

### Step 5: The "Restore" Loop

This is where Git becomes a powerful part of the workflow.

- **If the changes are bad (e.g., introduce bugs, don't work as expected):**
  1.  Open the terminal in VS Code.
  2.  Run the command: `git restore .`
  3.  This command instantly discards all uncommitted changes in your workspace, reverting your files to the state of your last commit.
  4.  You are now back to a clean state and can go back to the Parallel Co-Pilot Panel, select a _different_ AI response, and click "Accept Selected Files" again to test the next proposed solution.

- **If the changes are good:**
  1.  Open the Source Control panel in VS Code.
  2.  Stage the changes (`git add .`).
  3.  Write a commit message (e.g., "Feat: Implement user login via AI suggestion C15").
  4.  Commit the changes.
  5.  You are now ready to start the next development cycle from a new, clean state.

This iterative loop of `accept -> test -> restore` allows you to rapidly audition multiple AI-generated solutions without fear of corrupting your codebase.
</T14. Template - GitHub Repository Setup Guide.md>

<T1. Template - Master Artifact List.md>

<!--
  IMPORTANT AI INSTRUCTION:
  When generating a file based on this template, you MUST wrap the entire file's content
  in <file path="src/Artifacts/[ProjectName]-A0-Master-Artifact-List.md"></file_artifact> tags.
-->

# Artifact T1: Template - Master Artifact List

# Date Created: C139

# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A generic template for a Master Artifact List, to be used as static context in the Cycle 0 prompt.
- **Tags:** template, cycle 0, documentation, project setup

## 1. Purpose

This file serves as the definitive, parseable list of all documentation artifacts for your project. Maintaining this list is crucial for organizing project knowledge and ensuring that both human developers and AI assistants have a clear map of the "Source of Truth" documents.

## 2. Formatting Rules for Parsing

- Lines beginning with `#` are comments and are ignored.
- `##` denotes a major category header and is ignored.
- `###` denotes an artifact entry. The text following it is the artifact's full name and ID.
- Lines beginning with `- **Description:**` provide context for the project.
- Lines beginning with `- **Tags:**` provide keywords for Inference.

## 3. Example Structure

## I. Project Planning & Design

### A1. [Your Project Name] - Project Vision and Goals

- **Description:** High-level overview of the project, its purpose, and the development plan.
- **Tags:** project vision, goals, scope, planning

### A2. [Your Project Name] - Phase 1 - Requirements & Design

- **Description:** Detailed functional and technical requirements for the first phase of the project.
- **Tags:** requirements, design, phase 1, features
  </T1. Template - Master Artifact List.md>

<T2. Template - Project Vision and Goals.md>

<!--
  IMPORTANT AI INSTRUCTION:
  When generating a file based on this template, you MUST wrap the entire file's content
  in <file path="src/Artifacts/[ProjectName]-A1-Project-Vision-and-Goals.md"></file_artifact> tags.
-->

# Artifact T2: Template - Project Vision and Goals

# Date Created: C139

# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A generic template for a Project Vision and Goals document.
- **Tags:** template, cycle 0, documentation, project setup

## 1. Project Vision

The vision of **[Your Project Name]** is to **[State the core problem you are solving and the ultimate goal of the project]**. It aims to provide a **[brief description of the product or system]** that will **[describe the key benefit or value proposition]**.

## 2. High-Level Goals & Phases

The project will be developed in distinct phases to ensure an iterative and manageable workflow.

### Phase 1: [Name of Phase 1, e.g., Core Functionality]

The goal of this phase is to establish the foundational elements of the project.

- **Core Functionality:** [Describe the most critical feature to be built first].
- **Outcome:** [Describe the state of the project at the end of this phase, e.g., "A user can perform the core action of X"].

### Phase 2: [Name of Phase 2, e.g., Feature Expansion]

This phase will build upon the foundation of Phase 1 by adding key features that enhance the user experience.

- **Core Functionality:** [Describe the next set of important features].
- **Outcome:** [Describe the state of the project at the end of this phase].

### Phase 3: [Name of Phase 3, e.g., Scalability and Polish]

This phase focuses on refining the product, improving performance, and ensuring it is ready for a wider audience.

- **Core Functionality:** [Describe features related to performance, security, or advanced user interactions].
- **Outcome:** [Describe the final, polished state of the project].
  </T2. Template - Project Vision and Goals.md>

<T3. Template - Phase 1 Requirements & Design.md>

<!--
  IMPORTANT AI INSTRUCTION:
  When generating a file based on this template, you MUST wrap the entire file's content
  in <file path="src/Artifacts/[ProjectName]-A2-Phase1-Requirements.md"></file_artifact> tags.
-->

# Artifact T3: Template - Phase 1 Requirements & Design

# Date Created: C139

# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A generic template for a requirements and design document.
- **Tags:** template, cycle 0, documentation, project setup

## 1. Overview

This document outlines the detailed requirements for Phase 1 of **[Your Project Name]**. The primary goal of this phase is to implement the core functionality as defined in the Project Vision.

## 2. Functional Requirements

| ID    | Requirement                | User Story                                                                       | Acceptance Criteria                                                                                    |
| ----- | -------------------------- | -------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| FR-01 | **[Feature Name]**         | As a [user type], I want to [perform an action], so that [I can achieve a goal]. | - [Criterion 1: A specific, testable outcome] <br> - [Criterion 2: Another specific, testable outcome] |
| FR-02 | **[Another Feature Name]** | As a [user type], I want to [perform an action], so that [I can achieve a goal]. | - [Criterion 1] <br> - [Criterion 2]                                                                   |

## 3. Non-Functional Requirements

| ID     | Requirement     | Description                                                                                                           |
| ------ | --------------- | --------------------------------------------------------------------------------------------------------------------- |
| NFR-01 | **Performance** | The core action of [describe action] should complete in under [time, e.g., 500ms].                                    |
| NFR-02 | **Usability**   | The user interface should be intuitive and follow standard design conventions for [platform, e.g., web applications]. |

## 4. High-Level Design

The implementation of Phase 1 will involve the following components:

- **[Component A]:** Responsible for [its primary function].
- **[Component B]:** Responsible for [its primary function].
- **[Data Model]:** The core data will be structured as [describe the basic data structure].
  </T3. Template - Phase 1 Requirements & Design.md>

<T4. Template - Technical Scaffolding Plan.md>

<!--
  IMPORTANT AI INSTRUCTION:
  When generating a file based on this template, you MUST wrap the entire file's content
  in <file path="src/Artifacts/[ProjectName]-A3-Technical-Scaffolding-Plan.md"></file_artifact> tags.
-->

# Artifact T4: Template - Technical Scaffolding Plan

# Date Created: C139

# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A generic template for a technical scaffolding plan.
- **Tags:** template, cycle 0, documentation, project setup

## 1. Overview

This document outlines the proposed technical scaffolding and file structure for **[Your Project Name]**. This plan serves as a blueprint for the initial project setup, ensuring a clean, scalable, and maintainable architecture from the start.

## 2. Technology Stack

- **Language:** [e.g., TypeScript]
- **Framework/Library:** [e.g., React, Node.js with Express]
- **Styling:** [e.g., SCSS, TailwindCSS]
- **Bundler:** [e.g., Webpack, Vite]

## 3. Proposed File Structure

The project will adhere to a standard, feature-driven directory structure:

```
.
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ components/       # Reusable UI components (e.g., Button, Modal)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ features/         # Feature-specific modules
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [feature-one]/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ components/
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ services/         # Core backend or client-side services (e.g., api.service.ts)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ types/            # Shared TypeScript type definitions
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ main.ts           # Main application entry point
‚îÇ
‚îú‚îÄ‚îÄ package.json          # Project manifest and dependencies
‚îî‚îÄ‚îÄ tsconfig.json         # TypeScript configuration
```

## 4. Key Architectural Concepts

- **Separation of Concerns:** The structure separates UI components, feature logic, and core services.
- **Component-Based UI:** The UI will be built by composing small, reusable components.
- **Service Layer:** Business logic and external communication (e.g., API calls) will be encapsulated in services to keep components clean.
- **Strong Typing:** TypeScript will be used throughout the project to ensure type safety and improve developer experience.
  </T4. Template - Technical Scaffolding Plan.md>

<T5. Template - Target File Structure.md>

<!--
  IMPORTANT AI INSTRUCTION:
  When generating a file based on this template, you MUST wrap the entire file's content
  in <file path="src/Artifacts/[ProjectName]-A5-Target-File-Structure.md"></file_artifact> tags.
-->

# Artifact T5: Template - Target File Structure

# Date Created: C139

# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A generic template for a target file structure document.
- **Tags:** template, cycle 0, documentation, project setup

## 1. Overview

This document provides a visual representation of the file structure that the `T6. Template - Initial Scaffolding Deployment Script` will create. It is based on the architecture defined in `T4. Template - Technical Scaffolding Plan`.

## 2. File Tree

```
[Your Project Name]/
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ src/
    ‚îú‚îÄ‚îÄ components/
    ‚îÇ   ‚îî‚îÄ‚îÄ placeholder.ts
    ‚îú‚îÄ‚îÄ features/
    ‚îÇ   ‚îî‚îÄ‚îÄ placeholder.ts
    ‚îú‚îÄ‚îÄ services/
    ‚îÇ   ‚îî‚îÄ‚îÄ placeholder.ts
    ‚îú‚îÄ‚îÄ types/
    ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
    ‚îî‚îÄ‚îÄ main.ts
```

</T5. Template - Target File Structure.md>

<T6. Template - Initial Scaffolding Deployment Script.md>

<!--
  IMPORTANT AI INSTRUCTION:
  When generating a file based on this template, you MUST wrap the entire file's content
  in <file path="src/Artifacts/[ProjectName]-A6-Scaffolding-Script.md"></file_artifact> tags.
-->

# Artifact T6: Template - Initial Scaffolding Deployment Script (DEPRECATED)

# Date Created: C139

# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** (Deprecated) A generic template for a scaffolding deployment script. This is obsolete.
- **Tags:** template, cycle 0, documentation, project setup, deprecated

## 1. Overview

This artifact contains a simple Node.js script (`deploy_scaffold.js`). Its purpose is to automate the creation of the initial project structure for **[Your Project Name]**, as outlined in `T5. Template - Target File Structure`.

**Note:** This approach is now considered obsolete. The preferred method is to have the AI generate the necessary files directly in its response.

## 2. How to Use

1.  Save the code below as `deploy_scaffold.js` in your project's root directory.
2.  Open a terminal in that directory.
3.  Run the script using Node.js: `node deploy_scaffold.js`

## 3. Script: `deploy_scaffold.js`

```javascript
const fs = require("fs").promises;
const path = require("path");

const filesToCreate = [
  {
    path: "package.json",
    content: '{ "name": "my-new-project", "version": "0.0.1" }',
  },
  {
    path: "tsconfig.json",
    content: '{ "compilerOptions": { "strict": true } }',
  },
  { path: ".gitignore", content: "node_modules\ndist" },
  { path: "src/main.ts", content: "// Main application entry point" },
  { path: "src/components/placeholder.ts", content: "// Reusable components" },
  { path: "src/features/placeholder.ts", content: "// Feature modules" },
  { path: "src/services/placeholder.ts", content: "// Core services" },
  { path: "src/types/index.ts", content: "// Shared types" },
];

async function deployScaffold() {
  console.log("Deploying project scaffold...");
  const rootDir = process.cwd();

  for (const file of filesToCreate) {
    const fullPath = path.join(rootDir, file.path);
    const dir = path.dirname(fullPath);

    try {
      await fs.mkdir(dir, { recursive: true });
      await fs.writeFile(fullPath, file.content, "utf-8");
      console.log(`‚úÖ Created: ${file.path}`);
    } catch (error) {
      console.error(`‚ùå Failed to create ${file.path}: ${error.message}`);
    }
  }
  console.log("\nüöÄ Scaffold deployment complete!");
}

deployScaffold();
```

</T6. Template - Initial Scaffolding Deployment Script.md>

<T8. Template - Regression Case Studies.md>

<!--
  IMPORTANT AI INSTRUCTION:
  When generating a file based on this template, you MUST wrap the entire file's content
  in <file path="src/Artifacts/[ProjectName]-A8-Regression-Case-Studies.md"></file_artifact> tags.
-->

# Artifact T8: Template - Regression Case Studies

# Date Created: C141

# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A generic template for a regression case studies document, promoting development best practices.
- **Tags:** template, cycle 0, documentation, project setup

## 1. Purpose

This document serves as a living record of persistent or complex bugs that have recurred during development. By documenting the root cause analysis (RCA) and the confirmed solution for each issue, we create a "source of truth" that can be referenced to prevent the same mistakes from being reintroduced into the codebase.

## 2. Case Studies

---

### Case Study 001: [Name of the Bug]

- **Artifacts Affected:** [List of files, e.g., `src/components/MyComponent.tsx`, `src/services/api.service.ts`]
- **Cycles Observed:** [e.g., C10, C15]
- **Symptom:** [Describe what the user sees. e.g., "When a user clicks the 'Save' button, the application crashes silently."]
- **Root Cause Analysis (RCA):** [Describe the underlying technical reason for the bug. e.g., "The API service was not correctly handling a null response from the server. A race condition occurred where the UI component would unmount before the API promise resolved, leading to a state update on an unmounted component."]
- **Codified Solution & Best Practice:**
  1.  [Describe the specific code change, e.g., "The API service was updated to always return a default object instead of null."]
  2.  [Describe the pattern or best practice to follow, e.g., "All API calls made within a React component's `useEffect` hook must include a cleanup function to cancel the request or ignore the result if the component unmounts."]

---

</T8. Template - Regression Case Studies.md>

<T9. Template - Logging and Debugging Guide.md>

<!--
  IMPORTANT AI INSTRUCTION:
  When generating a file based on this template, you MUST wrap the entire file's content
  in <file path="src/Artifacts/[ProjectName]-A9-Logging-and-Debugging.md"></file_artifact> tags.
-->

# Artifact T9: Template - Logging and Debugging Guide

# Date Created: C141

# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A generic template for a logging and debugging guide.
- **Tags:** template, cycle 0, documentation, project setup

## 1. Purpose

This document provides instructions on how to access and use the logging features built into the project. Effective logging is crucial for diagnosing performance issues, tracking down bugs, and understanding the application's behavior during development.

## 2. Log Locations

### Location 1: The Browser Developer Console

This is where you find logs from the **frontend**.

- **What you'll see here:** `console.log()` statements from React components and client-side scripts.
- **Where to find it:** Open your browser, right-click anywhere on the page, select "Inspect", and navigate to the "Console" tab.

### Location 2: The Server Terminal

This is where you find logs from the **backend** (the Node.js process).

- **What you'll see here:** `console.log()` statements from your server-side code, API handlers, and services.
- **Where to find it:** The terminal window where you started the server (e.g., via `npm start`).

## 3. Tactical Debugging with Logs

When a feature is not working as expected, the most effective debugging technique is to add **tactical logs** at every step of the data's journey to pinpoint where the process is failing.

### Example Data Flow for Debugging:

1.  **Frontend Component (`MyComponent.tsx`):** Log the user's input right before sending it.
    `console.log('[Component] User clicked save. Sending data:', dataToSend);`
2.  **Frontend Service (`api.service.ts`):** Log the data just before it's sent over the network.
    `console.log('[API Service] Making POST request to /api/data with body:', body);`
3.  **Backend Route (`server.ts`):** Log the data as soon as it's received by the server.
    `console.log('[API Route] Received POST request on /api/data with body:', req.body);`
4.  **Backend Service (`database.service.ts`):** Log the data just before it's written to the database.
    `console.log('[DB Service] Attempting to write to database:', data);`

By following the logs through this chain, you can identify exactly where the data becomes corrupted, is dropped, or causes an error.
</T9. Template - Logging and Debugging Guide.md>

<T10. Template - Feature Plan Example.md>

<!--
  IMPORTANT AI INSTRUCTION:
  When generating a file based on this template, you MUST wrap the entire file's content
  in <file path="src/Artifacts/[ProjectName]-A10-Feature-Plan-Example.md"></file_artifact> tags.
-->

# Artifact T10: Template - Feature Plan Example

# Date Created: C141

# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A generic template for a feature plan, using a right-click context menu as an example.
- **Tags:** template, cycle 0, documentation, project setup

## 1. Overview & Goal

This document outlines the plan for implementing a standard right-click context menu. The goal is to provide essential management operations directly within the application, reducing the need for users to switch contexts for common tasks.

## 2. User Stories

| ID    | User Story         | Acceptance Criteria                                                                                                 |
| ----- | ------------------ | ------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| US-01 | **Copy Item Name** | As a user, I want to right-click an item and copy its name to my clipboard, so I can easily reference it elsewhere. | - Right-clicking an item opens a context menu. <br> - The menu contains a "Copy Name" option. <br> - Selecting the option copies the item's name string to the system clipboard.  |
| US-02 | **Rename Item**    | As a user, I want to right-click an item and rename it, so I can correct mistakes or update its label.              | - The context menu contains a "Rename" option. <br> - Selecting it turns the item's name into an editable input field. <br> - Pressing Enter or clicking away saves the new name. |
| US-03 | **Delete Item**    | As a user, I want to right-click an item and delete it, so I can remove unnecessary items.                          | - The context menu contains a "Delete" option. <br> - Selecting it shows a confirmation dialog to prevent accidental deletion. <br> - Upon confirmation, the item is removed.     |

## 3. Technical Implementation Plan

- **State Management:** Introduce new state to manage the context menu's visibility and position: `const [contextMenu, setContextMenu] = useState<{ x: number; y: number; item: any } | null>(null);`.
- **Event Handling:** Add an `onContextMenu` handler to the item element. This will prevent the default browser menu and set the state to show our custom menu at the event's coordinates.
- **New Menu Component:** Render a custom context menu component conditionally based on the `contextMenu` state. It will contain the options defined in the user stories.
- **Action Handlers:** Implement the functions for `handleRename`, `handleDelete`, etc. These will be called by the menu items' `onClick` handlers.
- **Overlay:** An overlay will be added to the entire screen when the menu is open. Clicking this overlay will close the menu.
  </T10. Template - Feature Plan Example.md>

<T11. Template - Implementation Roadmap.md>

<!--
  IMPORTANT AI INSTRUCTION:
  When generating a file based on this template, you MUST wrap the entire file's content
  in <file path="src/Artifacts/[ProjectName]-A11-Implementation-Roadmap.md"></file_artifact> tags.
-->

# Artifact T11: Template - Implementation Roadmap

# Date Created: C152

# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A generic template for an implementation roadmap document, guiding the development process.
- **Tags:** template, cycle 0, documentation, project setup, roadmap

## 1. Overview & Goal

This document provides a clear, step-by-step roadmap for the implementation of **[Your Project Name]**. This roadmap breaks the project vision into smaller, manageable, and testable steps. The goal is to build the functionality incrementally, ensuring a stable foundation at each stage.

## 2. Implementation Steps

### Step 1: Foundational Setup & Core Logic

- **Goal:** Create the basic project structure and implement the single most critical feature.
- **Tasks:**
  1.  **Scaffolding:** Set up the initial file and directory structure based on the technical plan.
  2.  **Core Data Model:** Define the primary data structures for the application.
  3.  **Implement [Core Feature]:** Build the first, most essential piece of functionality (e.g., the main user action).
- **Outcome:** A runnable application with the core feature working in a basic form.

### Step 2: UI Development & User Interaction

- **Goal:** Build out the primary user interface and make the application interactive.
- **Tasks:**
  1.  **Component Library:** Create a set of reusable UI components (buttons, inputs, etc.).
  2.  **Main View:** Construct the main application view that users will interact with.
  3.  **State Management:** Implement robust state management to handle user input and data flow.
- **Outcome:** A visually complete and interactive user interface.

### Step 3: Feature Expansion

- **Goal:** Add secondary features that build upon the core functionality.
- **Tasks:**
  1.  **Implement [Feature A]:** Build the next most important feature.
  2.  **Implement [Feature B]:** Build another key feature.
  3.  **Integration:** Ensure all new features are well-integrated with the core application.
- **Outcome:** A feature-complete application ready for polishing.

### Step 4: Polish, Testing, and Deployment

- **Goal:** Refine the application, fix bugs, and prepare for release.
- **Tasks:**
  1.  **UI/UX Polish:** Address any minor layout, styling, or interaction issues.
  2.  **Testing:** Conduct thorough testing to identify and fix bugs.
  3.  **Documentation:** Write user-facing documentation and guides.
  4.  **Deployment:** Package and deploy the application.
- **Outcome:** A stable, polished, and documented application.
  </T11. Template - Implementation Roadmap.md>

<T12. Template - Competitive Analysis.md>

<!--
  IMPORTANT AI INSTRUCTION:
  When generating a file based on this template, you MUST wrap the entire file's content
  in <file path="src/Artifacts/A12. [Project Name] - Competitive Analysis.md">...</file_artifact> tags.
-->

# Artifact T12: [Project Name] - Competitive Analysis Template

# Date Created: C152

# Author: AI Model & Curator

# Updated on: C158 (Add guidance for researching AI-generated content)

- **Key/Value for A0:**
- **Description:** A generic template for a competitive analysis document, used for feature ideation.
- **Tags:** template, cycle 0, documentation, project setup, research

## 1. Overview

This document provides an analysis of existing tools and products that solve a similar problem to **[Project Name]**. The goal is to identify common features, discover innovative ideas, and understand the competitive landscape to ensure our project has a unique value proposition.

## 2. Research Summary

A search for "[keywords related to your project's core problem]" reveals several existing solutions. The market appears to be [describe the market: mature, emerging, niche, etc.]. The primary competitors or inspirational projects are [Competitor A], [Competitor B], and [Tool C].

The key pain point these tools address is [describe the common problem they solve]. The general approach is [describe the common solution pattern].

## 3. Existing Tools & Inspirations

| Tool / Product            | Relevant Features                                                | How It Inspires Your Project                                                                                                                                                                                  |
| :------------------------ | :--------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **[Competitor A]**        | - [Feature 1 of Competitor A] <br> - [Feature 2 of Competitor A] | This tool validates the need for [core concept]. Its approach to [Feature 1] is a good model, but we can differentiate by [your unique approach].                                                             |
| **[Competitor B]**        | - [Feature 1 of Competitor B] <br> - [Feature 2 of Competitor B] | The user interface of this tool is very polished. We should aim for a similar level of usability. Its weakness is [describe a weakness you can exploit].                                                      |
| **[Tool C]**              | - [Feature 1 of Tool C]                                          | This tool has an innovative feature, [Feature 1], that we had not considered. We should evaluate if a similar feature would fit into our project's scope.                                                     |
| **AI-Generated Projects** | - [Novel feature from an AI-generated example]                   | Researching other seemingly AI-generated solutions for similar problems can reveal novel approaches or features that are not yet common in human-developed tools. This can be a source of cutting-edge ideas. |

## 4. Feature Ideas & Opportunities

Based on the analysis, here are potential features and strategic opportunities for **[Project Name]**:

| Feature Idea                          | Description                                                                                                                                                   |
| :------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **[Differentiating Feature]**         | This is a key feature that none of the competitors offer. It would allow users to [describe the benefit] and would be our primary unique selling proposition. |
| **[Improvement on Existing Feature]** | Competitor A has [Feature 1], but it's slow. We can implement a more performant version by [your technical advantage].                                        |
| **[User Experience Enhancement]**     | Many existing tools have a complex setup process. We can win users by making our onboarding experience significantly simpler and more intuitive.              |

</T12. Template - Competitive Analysis.md>

<T13. Template - Refactoring Plan.md>

<!--
  IMPORTANT AI INSTRUCTION:
  When generating a file based on this template, you MUST wrap the entire file's content
  in <file path="src/Artifacts/[ProjectName]-A13-Refactoring-Plan.md"></file_artifact> tags.
-->

# Artifact T13: Template - Refactoring Plan

# Date Created: C152

# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A generic template for a refactoring plan, guiding users to consider constraints like token count.
- **Tags:** template, cycle 0, documentation, project setup, refactor

## 1. Problem Statement

The file `[path/to/problematic/file.ts]` has become difficult to maintain due to [e.g., its large size, high complexity, mixing of multiple responsibilities]. This is leading to [e.g., slower development, increased bugs, high token count for LLM context].

## 2. Refactoring Goals

1.  **Improve Readability:** Make the code easier to understand and follow.
2.  **Reduce Complexity:** Break down large functions and classes into smaller, more focused units.
3.  **Increase Maintainability:** Make it easier to add new features or fix bugs in the future.
4.  **Constraint:** The primary constraint for this refactor is to **reduce the token count** of the file(s) to make them more manageable for AI-assisted development.

## 3. Proposed Refactoring Plan

The monolithic file/class will be broken down into the following smaller, more focused modules/services:

### 3.1. New Service/Module A: `[e.g., DataProcessingService.ts]`

- **Responsibility:** This service will be responsible for all logic related to [e.g., processing raw data].
- **Functions/Methods to move here:**
  - `functionA()`
  - `functionB()`

### 3.2. New Service/Module B: `[e.g., ApiClientService.ts]`

- **Responsibility:** This service will encapsulate all external API communication.
- **Functions/Methods to move here:**
  - `fetchDataFromApi()`
  - `postDataToApi()`

### 3.3. Original File (`[e.g., MainController.ts]`):

- **Responsibility:** The original file will be simplified to act as a coordinator, orchestrating calls to the new services.
- **Changes:**
  - Remove the moved functions.
  - Import and instantiate the new services.
  - Update the main logic to delegate work to the appropriate service.

## 4. Benefits

- **Reduced Token Count:** The original file's token count will be significantly reduced.
- **Improved Maintainability:** Each new service has a single, clear responsibility.
- **Easier Testing:** The smaller, focused services will be easier to unit test in isolation.
  </T13. Template - Refactoring Plan.md>

<T15. Template - A-B-C Testing Strategy for UI Bugs.md>

<!--
  IMPORTANT AI INSTRUCTION:
  When generating a file based on this template, you MUST wrap the entire file's content
  in <file path="src/Artifacts/[ProjectName]-A15-ABC-Testing-Strategy.md"></file_artifact> tags.
-->

# Artifact T15: Template - A-B-C Testing Strategy for UI Bugs

# Date Created: C154

# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A generic template for a guide on using the A-B-C testing pattern to diagnose UI bugs.
- **Tags:** template, cycle 0, process, debugging, troubleshooting

## 1. Overview & Goal

When a user interface (UI) bug, particularly related to event handling (`onClick`, `onDrop`, etc.), proves resistant to conventional debugging, it often indicates a complex root cause. Continuously attempting small fixes on the main, complex component can be inefficient.

The goal of the **A-B-C Testing Strategy** is to break this cycle by creating a test harness with multiple, simplified, independent test components. Each test component attempts to solve the same basic problem using a slightly different technical approach, allowing for rapid diagnosis.

## 2. The Strategy

### 2.1. Core Principles

1.  **Preserve the Original:** Never remove existing functionality to build a test case. The original component should remain as the "control" in the experiment.
2.  **Isolate Variables:** Each test case should be as simple as possible, designed to test a single variable (e.g., raw event handling vs. local state updates).
3.  **Run in Parallel:** The original component and all test components should be accessible from the same UI (e.g., via tabs) for immediate comparison.

### 2.2. Steps

1.  **Identify the Core Problem:** Isolate the most fundamental action that is failing (e.g., "A click on a list item is not being registered").
2.  **Create Test Harness:** Refactor the main view to act as a "test harness" that can switch between the original component and several new test components.
3.  **Implement Isolated Test Components:** Create new, simple components for each test case.
    - **Test A (Barebones):** The simplest possible implementation. Use raw HTML elements with inline event handlers that only log to the console.
    - **Test B (Local State):** Introduce state management to test the component's ability to re-render on an event.
    - **Test C (Prop-Driven):** Use a child component that calls a function passed down via props, testing the prop-drilling pattern.
4.  **Analyze Results:** Interact with each tab to see which implementation succeeds, thereby isolating the architectural pattern that is failing.

## 3. Cleanup Process

Once a working pattern is identified in a test component:

1.  **Codify Findings:** Document the successful pattern and the root cause of the failure.
2.  **Integrate Solution:** Refactor the original component to use the successful pattern.
3.  **Remove Test Artifacts:** Delete the test harness UI and the temporary test component files.
    </T15. Template - A-B-C Testing Strategy for UI Bugs.md>

<T16. Template - Developer Environment Setup Guide.md>

<!--
  IMPORTANT AI INSTRUCTION:
  When generating a file based on this template, you MUST wrap the entire file's content
  in <file path="src/Artifacts/A16. [Project Name] - Developer Environment Setup Guide.md">...</file_artifact> tags.
-->

# Artifact T16: [Project Name] - Developer Environment Setup Guide Template

# Date Created: C158

# Author: AI Model & Curator

# Updated on: C160 (Add section for managing environment variables)

- **Key/Value for A0:**
- **Description:** A generic template for a guide on setting up a new project's development environment, including OS, tools, and installation steps.
- **Tags:** template, cycle 0, documentation, project setup, environment

## 1. Overview

This document provides a step-by-step guide for setting up the local development environment required to build and run **[Project Name]**. Following these instructions will ensure that all developers have a consistent and correct setup.

## 2. System Requirements

Before you begin, please ensure your system meets the following requirements. This information is critical for providing the correct commands and troubleshooting steps in subsequent development cycles.

- **Operating System:** [e.g., Windows 11, macOS Sonoma, Ubuntu 22.04]
- **Package Manager:** [e.g., npm, yarn, pnpm]
- **Node.js Version:** [e.g., v20.11.0 or later]
- **Code Editor:** Visual Studio Code (Recommended)

## 3. Required Tools & Software

Please install the following tools if you do not already have them:

1.  **Node.js:** [Provide a link to the official Node.js download page: https://nodejs.org/]
2.  **Git:** [Provide a link to the official Git download page: https://git-scm.com/downloads]
3.  **[Any other required tool, e.g., Docker, Python]:** [Link to installation guide]

## 4. Step-by-Step Setup Instructions

### Step 1: Clone the Repository

First, clone the project repository from GitHub to your local machine.

```bash
# Replace with your repository URL
git clone https://github.com/your-username/your-project.git
cd your-project
```

### Step 2: Install Project Dependencies

Next, install all the necessary project dependencies using your package manager.

```bash
# For npm
npm install

# For yarn
# yarn install
```

### Step 3: Configure Environment Variables

Create a `.env` file in the root of the project by copying the example file.

```bash
cp .env.example .env
```

Now, open the `.env` file and fill in the required environment variables:

- `API_KEY`: [Description of what this key is for]
- `DATABASE_URL`: [Description of the database connection string]

### Step 4: Run the Development Server

To start the local development server, run the following command. This will typically compile the code and watch for any changes you make.

```bash
# For npm
npm run dev

# For yarn
# yarn dev
```

### Step 5: Verify the Setup

Once the development server is running, you should be able to access the application at [e.g., `http://localhost:3000`]. [Describe what the developer should see to confirm that the setup was successful].

## 5. Managing Environment Variables and Secrets

To provide an AI assistant with the necessary context about which environment variables are available without exposing sensitive secrets, follow this best practice:

1.  **Create a `.env.local` file:** Make a copy of your `.env` file and name it `.env.local`.
2.  **Redact Secret Values:** In the `.env.local` file, replace all sensitive values (like API keys, passwords, or tokens) with the placeholder `[REDACTED]`.
3.  **Include in Context:** When curating your context for the AI, check the box for the `.env.local` file.
4.  **Exclude `.env`:** Ensure your `.gitignore` file includes `.env` to prevent your actual secrets from ever being committed to version control.

This allows the AI to see the names of all available constants (e.g., `OPENAI_API_KEY`) so it can write code that uses them correctly, but it never sees the actual secret values.
</T16. Template - Developer Environment Setup Guide.md>

<T17. Template - Universal Task Checklist.md>

# Artifact A[XX]: [Project Name] - Universal Task Checklist

# Date Created: C[XX]

# Author: AI Model & Curator

# Updated on: C10 (Add guidance for planning next cycle)

- **Key/Value for A0:**
- **Description:** A generic template for a universal task checklist, designed to organize work by file and complexity.
- **Tags:** template, process, checklist, task management, planning

## 1. Purpose

This artifact provides a structured, universal format for tracking development tasks, feedback, and bugs. Unlike cycle-specific trackers, this checklist organizes work by the group of files involved in a given task. It also introduces a simple complexity metric based on the total token count of the affected files and an estimation of whether the task will require more than one development cycle to complete.

This file-centric approach helps in planning and prioritizing work, especially in an AI-assisted development workflow where context size (token count) is a primary constraint.

## 2. How to Use

- **Group by File Packages:** Create a new `##` section for each logical task or feature. List all the files that are expected to be modified for this task.
- **Assign an ID:** Give each task package a unique, simple ID (e.g., `T-1`, `T-2`) for easy reference in feedback.
- **Estimate Complexity:**
  - Calculate the **Total Tokens** for all files in the package. This gives a quantitative measure of the context size.
  - Estimate if the task is likely to take **More than one cycle?**. This is a qualitative judgment based on the complexity of the changes required.
- **List Action Items:** Under each file package, create a checklist of specific actions, bugs to fix, or features to implement.
- **Add Verification Steps:** After the action items, add a section describing how the curator should test the feature to confirm it is working as expected.
- **Note on Output Length:** Remember that the maximum output length for a single response is approximately 65,000 tokens. Do not prematurely stop generating files; attempt to complete as many full files as possible within this limit.
- **Plan for the Future:** Always conclude your task list with a final task to create the checklist for the next cycle (e.g., `T-X: Create A[XX+1] Universal Task Checklist for Cycle [Y+]`). This creates a continuous planning loop.
- **Keep it Current:** At the beginning of each new cycle, review and update this checklist. Move completed tasks to a "Completed" section, add new tasks based on feedback, and re-prioritize as needed. This ensures the checklist remains a living, accurate reflection of the project's status.

---

## Example Task List

## T-1: [Feature Name or Bug Area]

- **Files Involved:**
  - `src/path/to/fileA.ts`
  - `src/path/to/fileB.tsx`
- **Total Tokens:** [e.g., ~5,500]
- **More than one cycle?** [e.g., No]

- [ ] **Task (T-ID: 1.1):** [Description of the first action item]
- [ ] **Bug Fix (T-ID: 1.2):** [Description of the bug to be fixed]

### Verification Steps

1.  [First verification step]
2.  **Expected:** [Expected outcome of the first step]
3.  [Second verification step]
4.  **Expected:** [Expected outcome of the second step]

## T-2: Plan for Next Cycle

- **Files Involved:**
  - `src/Artifacts/A[XX+1]-New-Checklist.md`
- **Total Tokens:** [e.g., ~500]
- **More than one cycle?** No

- [ ] **Task (T-ID: 2.1):** Create the Universal Task Checklist for the next cycle based on current progress and backlog.
      </T17. Template - Universal Task Checklist.md>

<!-- END: Project Templates -->

</Static Context>
</Cycle 0>
</M6. Cycles>

<M7. Flattened Repo>
<file path="src/Artifacts/DCE_README.md">

# Artifact A72: DCE - README for Artifacts

# Date Created: C158

# Author: AI Model & Curator

# Updated on: C183 (Strengthen Git initialization and `.gitignore` guidance)

- **Key/Value for A0:**
- **Description:** The content for the `README.md` file that is automatically created in a new project's `src/Artifacts` directory, explaining the purpose of the extension and the artifact-driven workflow.
- **Tags:** documentation, onboarding, readme, source of truth

## 1. Welcome to the Data Curation Environment (DCE)

This directory (`src/Artifacts/`) is the heart of your project's planning and documentation. It's managed by the **Data Curation Environment (DCE)**, a VS Code extension designed to streamline AI-assisted development.

This `README.md` file was automatically generated to provide context for you (the developer) and for the AI assistants you will be working with.

## 2. What is an "Artifact"?

In the context of this workflow, an **Artifact** is a formal, written document that serves as a "source of truth" for a specific part of your project. Think of these files as the official blueprints, plans, and records.

The core principle of the DCE workflow is **"Documentation First."** Before writing code, you and your AI partner should first create or update an artifact that describes the plan.

## 3. The Iterative Cycle Workflow

Development in the DCE is organized into **Cycles**. You have just completed the initial setup.

### Your Next Steps

1.  **Initialize Your Git Repository (CRITICAL):**
    To take full advantage of the DCE's testing workflow (creating baselines and restoring changes), you **must** initialize a Git repository.

    Open a terminal in your project's root directory (you can use the integrated terminal in VS Code: `Terminal > New Terminal`) and run the following commands:

    ```bash
    git init
    # Create or update your .gitignore file with the line below
    echo ".vscode/" >> .gitignore
    git add .
    git commit -m "Initial commit"
    ```

    **Why `.gitignore`?** The DCE saves its state in a `.vscode/dce_history.json` file. Adding `.vscode/` to your `.gitignore` is crucial to prevent the extension's UI from flashing every time it auto-saves. For a complete guide, refer to the `GitHub Repository Setup Guide.md` artifact.

2.  **Submit Your First Prompt:** The `prompt.md` file has been automatically opened for you. This file contains your project plan and instructions for the AI. Copy its entire contents and paste it into your preferred AI chat interface (like Google's AI Studio, ChatGPT, etc.).

3.  **Review and Accept Responses:** Paste the AI's responses back into the "Resp 1", "Resp 2", etc. tabs in the Parallel Co-Pilot panel. The UI will guide you through parsing the responses, selecting the best one, and accepting its changes into your workspace.

4.  **Repeat:** This completes a cycle. You then start the next cycle, building upon the newly accepted code and documentation.

This structured, iterative process helps maintain project quality and ensures that both human and AI developers are always aligned with the project's goals.
</file_artifact>
</M7. Flattened Repo>

</prompt.md>
